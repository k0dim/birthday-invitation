name: üöÄ Production Deployment Pipeline

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –≤—Å–µ–≥–æ workflow
permissions:
  contents: read
  actions: write
  deployments: write
  statuses: write

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: 'birthday-invitation'
  NODE_VERSION: '20'
  DOCKER_REGISTRY: 'ghcr.io'
  DOCKER_IMAGE_NAME: '${{ github.repository }}'

jobs:
  # ==================== VALIDATION ====================
  validate:
    name: üîç Validate
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Validate Docker files
      run: |
        echo "üê≥ Validating Docker configuration..."
        
        required_docker_files=(
          "infra/docker/Dockerfile"
          "infra/docker/docker-compose.yml"
          "infra/nginx/nginx.conf"
          "infra/nginx/default.conf"
        )
        
        for file in "${required_docker_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "‚ùå Missing Docker file: $file"
            exit 1
          else
            echo "‚úÖ $file found"
          fi
        done
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º Dockerfile
        if ! grep -q "FROM nginx" infra/docker/Dockerfile; then
          echo "‚ö†Ô∏è Dockerfile might be misconfigured"
        fi
        
        echo "‚úÖ Docker configuration validated"

  # ==================== BUILD DOCKER ====================
  build:
    name: üê≥ Build Docker Image
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      version: ${{ steps.extract_version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Extract version
      id: extract_version
      run: |
        VERSION=$(node -p "require('./package.json').version 2>/dev/null || '1.0.0'")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Version: $VERSION"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{sha}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ steps.extract_version.outputs.version }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./infra/docker/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
          VITE_APP_VERSION=${{ steps.extract_version.outputs.version }}
    
    - name: Verify pushed image
      run: |
        echo "‚úÖ Docker image built and pushed"
        echo "Tags: ${{ steps.meta.outputs.tags }}"

  # ==================== DEPLOY DOCKER ====================
  deploy:
    name: üöÄ Deploy Docker Container
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 30
    environment: 
      name: production
      url: https://${{ vars.DOMAIN }}
    
    steps:
    - name: Setup SSH
      run: |
        echo "üîê Setting up SSH connection..."
        
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        cat >> ~/.ssh/config << EOF
        Host deploy-server
          HostName ${{ secrets.SERVER_IP }}
          User ${{ secrets.DEPLOY_USER }}
          IdentityFile ~/.ssh/deploy_key
          Port 22
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
        EOF
        
        chmod 600 ~/.ssh/config
    
    - name: Verify server connectivity
      run: |
        echo "üîç Testing server connectivity..."
        ssh deploy-server "echo '‚úÖ SSH connection successful!'"
        ssh deploy-server "
          echo '=== Docker Status ==='
          docker --version
          docker-compose --version
          echo ''
          echo '=== Disk Space ==='
          df -h
        "
    
    - name: Prepare deployment files on server
      run: |
        echo "üìÅ Preparing deployment directory on server..."
        
        # –ö–æ–ø–∏—Ä—É–µ–º Docker Compose —Ñ–∞–π–ª—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        scp infra/docker/docker-compose.yml deploy-server:/tmp/docker-compose.yml
        
        # –°–æ–∑–¥–∞–µ–º production docker-compose.prod.yml
        cat > docker-compose.prod.yml << 'EOF'
        version: '3.8'

        services:
          birthday-invitation:
            image: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
            container_name: ${{ env.APP_NAME }}-prod
            restart: unless-stopped
            ports:
              - "80:80"
              - "443:443"
            volumes:
              - ./infra/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
              - ./infra/nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
              - ssl-certs:/etc/nginx/ssl:ro
            environment:
              - VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
              - VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
            networks:
              - web-network

        volumes:
          ssl-certs:
            external: true

        networks:
          web-network:
            driver: bridge
        EOF
        
        # –°–æ–∑–¥–∞–µ–º —Å–∫—Ä–∏–ø—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SSL
        cat > generate-ssl.sh << 'EOF'
        #!/bin/bash
        set -e
        
        DOMAIN="${{ secrets.DOMAIN }}"
        SSL_DIR="./ssl-certs"
        
        echo "üîê Generating self-signed SSL certificate for \$DOMAIN..."
        
        mkdir -p \$SSL_DIR
        
        # Generate private key
        openssl genrsa -out \$SSL_DIR/selfsigned.key 2048
        
        # Generate CSR
        openssl req -new -key \$SSL_DIR/selfsigned.key -out \$SSL_DIR/selfsigned.csr \
          -subj "/C=RU/ST=Moscow/L=Moscow/O=Birthday/CN=\$DOMAIN"
        
        # Generate self-signed certificate
        openssl x509 -req -days 365 -in \$SSL_DIR/selfsigned.csr \
          -signkey \$SSL_DIR/selfsigned.key -out \$SSL_DIR/selfsigned.crt
        
        # Set permissions
        chmod 600 \$SSL_DIR/selfsigned.key
        chmod 644 \$SSL_DIR/selfsigned.crt
        
        # Create Docker volume
        docker volume create ssl-certs
        docker run --rm -v ssl-certs:/target -v \$(pwd)/\$SSL_DIR:/source alpine \
          sh -c "cp -r /source/* /target/"
        
        echo "‚úÖ SSL certificate generated and stored in Docker volume"
        EOF
        
        chmod +x generate-ssl.sh
        
        # –ö–æ–ø–∏—Ä—É–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        scp docker-compose.prod.yml deploy-server:/tmp/docker-compose.prod.yml
        scp generate-ssl.sh deploy-server:/tmp/generate-ssl.sh
        
        # –ö–æ–ø–∏—Ä—É–µ–º Nginx –∫–æ–Ω—Ñ–∏–≥–∏
        ssh deploy-server "mkdir -p ~/app/infra/nginx"
        scp infra/nginx/nginx.conf deploy-server:~/app/infra/nginx/
        scp infra/nginx/default.conf deploy-server:~/app/infra/nginx/
        
        # –û–±–Ω–æ–≤–ª—è–µ–º default.conf —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º root
        ssh deploy-server "
          cat > ~/app/infra/nginx/default.conf << 'NGINX_CONFIG'
        server {
            listen 80;
            listen [::]:80;
            server_name _;
            
            root /usr/share/nginx/html;
            index index.html index.htm;
            
            # Gzip —Å–∂–∞—Ç–∏–µ
            gzip on;
            gzip_vary on;
            gzip_min_length 1024;
            gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
            
            # –ó–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            add_header X-Frame-Options 'SAMEORIGIN' always;
            add_header X-Content-Type-Options 'nosniff' always;
            add_header X-XSS-Protection '1; mode=block' always;
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ SPA —Ä–æ—É—Ç–∏–Ω–≥–∞
            location / {
                try_files \$uri \$uri/ /index.html;
            }
            
            # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏–∫–∏
            location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)\$ {
                expires 1y;
                add_header Cache-Control 'public, immutable';
            }
            
            # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–∫—Ä—ã—Ç—ã–º —Ñ–∞–π–ª–∞–º
            location ~ /\\. {
                deny all;
            }
            
            # Health check
            location /health {
                access_log off;
                return 200 'healthy\\n';
                add_header Content-Type text/plain;
            }
            
            # Version endpoint
            location /version {
                alias /usr/share/nginx/html/.version;
                access_log off;
                add_header Content-Type text/plain;
            }
            
            # –°—Ç—Ä–∞–Ω–∏—Ü–∞ –æ—à–∏–±–æ–∫
            error_page 404 /index.html;
            error_page 500 502 503 504 /50x.html;
            location = /50x.html {
                root /usr/share/nginx/html;
            }
        }
        NGINX_CONFIG
        "
    
    - name: Login to GitHub Container Registry on server
      run: |
        echo "üîê Logging in to GitHub Container Registry on server..."
        
        ssh deploy-server "
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} \
            -u '${{ github.actor }}' \
            --password-stdin
        "
    
    - name: Generate SSL certificates on server
      run: |
        echo "üîê Generating SSL certificates on server..."
        
        ssh deploy-server "
          cd ~/app
          
          # Generate SSL certificates if not exist
          if ! docker volume inspect ssl-certs > /dev/null 2>&1; then
            echo 'Creating SSL certificates...'
            /tmp/generate-ssl.sh
          else
            echo 'SSL certificates already exist, skipping generation...'
          fi
        "
    
    - name: Deploy with Docker Compose
      run: |
        echo "üöÄ Deploying with Docker Compose..."
        
        ssh deploy-server "
          cd ~/app
          
          # Stop and remove old container if exists
          docker-compose -f /tmp/docker-compose.prod.yml down || true
          
          # Pull latest image
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          
          # Start new container
          docker-compose -f /tmp/docker-compose.prod.yml up -d
          
          # Verify container is running
          echo '=== Container Status ==='
          docker ps --filter 'name=${{ env.APP_NAME }}'
          
          echo '=== Container Logs (last 10 lines) ==='
          docker logs ${{ env.APP_NAME }}-prod --tail 10 2>&1 || echo 'No logs yet'
        "
    
    - name: Verify deployment
      run: |
        echo "üîç Verifying deployment..."
        
        sleep 10
        
        ssh deploy-server "
          echo '=== Docker Container Status ==='
          docker ps --filter 'name=${{ env.APP_NAME }}' --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}'
          
          echo ''
          echo '=== Application Health Check ==='
          curl -f http://localhost/health || echo 'Health check failed'
          
          echo ''
          echo '=== Nginx Configuration Test ==='
          docker exec ${{ env.APP_NAME }}-prod nginx -t 2>&1
          
          echo ''
          echo '=== Disk Usage ==='
          docker system df
        "
        
        # External check
        echo ''
        echo "=== External Verification ==="
        echo "Application should be available at:"
        echo "  ‚Ä¢ http://${{ secrets.SERVER_IP }}"
        echo "  ‚Ä¢ https://${{ secrets.DOMAIN }} (if DNS configured)"
        echo ''
        echo "To check SSL certificate:"
        echo "  openssl s_client -connect ${{ secrets.SERVER_IP }}:443 -servername ${{ secrets.DOMAIN }}"

  # ==================== POST-DEPLOYMENT ====================
  post_deploy:
    name: üìä Post-Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
    - name: Send deployment notification
      env:
        DEPLOY_STATUS: ${{ needs.deploy.result }}
        APP_NAME: ${{ env.APP_NAME }}
        SERVER_IP: ${{ secrets.SERVER_IP }}
        DOMAIN: ${{ secrets.DOMAIN }}
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "üì® Sending deployment notification..."
        
        if [ "$DEPLOY_STATUS" = "success" ]; then
          STATUS_EMOJI="‚úÖ"
          STATUS_TEXT="<b>–£–°–ü–ï–®–ù–û</b>"
        else
          STATUS_EMOJI="‚ùå"
          STATUS_TEXT="<b>–û–®–ò–ë–ö–ê</b>"
        fi
        
        cat > message.txt << EOF
        üê≥ <b>Docker Deploy $APP_NAME</b>
        
        $STATUS_EMOJI –°—Ç–∞—Ç—É—Å: $STATUS_TEXT
        üì¶ –†–µ–∂–∏–º: Docker Container
        üè∑Ô∏è –¢–µ–≥: latest
        
        üåê <b>–î–æ—Å—Ç—É–ø –∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é:</b>
        ‚Ä¢ http://$SERVER_IP
        ‚Ä¢ https://$DOMAIN
        
        üîß <b>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è:</b>
        ‚Ä¢ http://$SERVER_IP/health
        ‚Ä¢ http://$SERVER_IP/version
        
        üìä <b>–ö–æ–º–∞–Ω–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:</b>
        \`\`\`bash
        # –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ–≤
        docker logs $APP_NAME-prod
        
        # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        docker restart $APP_NAME-prod
        
        # –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        docker stats $APP_NAME-prod
        \`\`\`
        
        üïê <i>$(date '+%d.%m.%Y %H:%M:%S')</i>
        EOF
        
        MESSAGE=$(cat message.txt)
        
        curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
          -H "Content-Type: application/json" \
          -d "{
            \"chat_id\": \"$TELEGRAM_CHAT_ID\",
            \"text\": \"$(echo "$MESSAGE" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\\n/\\\\n/g')\",
            \"parse_mode\": \"HTML\",
            \"disable_web_page_preview\": true
          }"
        
        echo "‚úÖ Notification sent"
        rm -f message.txt