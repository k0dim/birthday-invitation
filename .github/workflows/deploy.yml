name: ğŸš€ Production Deployment Pipeline

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğ´Ğ»Ñ Ğ²ÑĞµĞ³Ğ¾ workflow
permissions:
  contents: read
  actions: write
  deployments: write
  statuses: write

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: 'birthday-invitation'
  NODE_VERSION: '20'
  DOCKER_REGISTRY: 'ghcr.io'
  DOCKER_IMAGE_NAME: '${{ github.repository }}'

jobs:
  # ==================== VALIDATION ====================
  validate:
    name: ğŸ” Validate
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Validate files
      run: |
        echo "ğŸ“ Validating project structure..."
        
        required_files=(
          "package.json"
          "infra/docker/Dockerfile.app"
          "infra/docker/docker-compose.yml"
          "infra/nginx/nginx.conf"
          "infra/nginx/sites/app.conf"
        )
        
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "âŒ Missing required file: $file"
            exit 1
          else
            echo "âœ… $file found"
          fi
        done
        
        echo "âœ… Project structure validated"
    
    - name: Extract version and metadata
      id: extract_metadata
      run: |
        VERSION=$(node -p "require('./package.json').version 2>/dev/null || '1.0.0'")
        COMMIT_SHORT="${GITHUB_SHA:0:7}"
        BUILD_ID="${COMMIT_SHORT}-$(date +%Y%m%d%H%M%S)"
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
        echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
        
        echo "ğŸ“¦ Version: $VERSION"
        echo "ğŸ·ï¸ Build ID: $BUILD_ID"
        echo "ğŸ”– Commit: $COMMIT_SHORT"

  # ==================== SECURITY ====================
  security:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: validate
    timeout-minutes: 10
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Dependency audit
      run: |
        echo "ğŸ›¡ï¸ Running dependency audit..."
        npm audit --audit-level=moderate || echo "âš ï¸ Audit found vulnerabilities (continuing)"
    
    - name: Docker security scan
      run: |
        echo "ğŸ³ Scanning Dockerfiles..."
        if command -v docker &> /dev/null; then
          docker run --rm -v "$(pwd):/app" aquasec/trivy:latest config /app || echo "âš ï¸ Trivy scan completed"
        else
          echo "â„¹ï¸ Docker not available for security scan"
        fi

  # ==================== BUILD ====================
  build:
    name: ğŸ³ Build & Push
    runs-on: ubuntu-latest
    needs: [validate, security]
    outputs:
      version: ${{ steps.extract_metadata.outputs.version }}
      build_id: ${{ steps.extract_metadata.outputs.build_id }}
      commit_short: ${{ steps.extract_metadata.outputs.commit_short }}
      image_tag: ${{ steps.build_image.outputs.image_tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: extract_metadata
      run: |
        VERSION=$(node -p "require('./package.json').version 2>/dev/null || '1.0.0'")
        COMMIT_SHORT="${GITHUB_SHA:0:7}"
        BUILD_ID="${COMMIT_SHORT}-$(date +%Y%m%d%H%M%S)"
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
        echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
    
    - name: Build and push Docker image
      id: build_image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./infra/docker/Dockerfile.app
        push: true
        tags: |
          ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.extract_metadata.outputs.version }}
          ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.extract_metadata.outputs.commit_short }}
          ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
        labels: |
          org.opencontainers.image.title=${{ env.APP_NAME }}
          org.opencontainers.image.version=${{ steps.extract_metadata.outputs.version }}
          org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          org.opencontainers.image.revision=${{ github.sha }}
        build-args: |
          VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Store image tag
      run: |
        echo "image_tag=${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:${{ steps.extract_metadata.outputs.version }}" >> $GITHUB_OUTPUT

  # ==================== DEPLOY ====================
  deploy:
    name: ğŸš€ Deploy to Server
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 30
    environment: 
      name: production
      url: https://${{ vars.DOMAIN }}
    
    steps:
    - name: Setup SSH
      run: |
        echo "ğŸ” Setting up SSH..."
        
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        cat >> ~/.ssh/config << EOF
        Host deploy-server
          HostName ${{ secrets.SERVER_IP }}
          User ${{ secrets.DEPLOY_USER }}
          IdentityFile ~/.ssh/deploy_key
          Port 22
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
          ConnectTimeout 30
        EOF
        
        chmod 600 ~/.ssh/config
        
        # Test connection
        ssh deploy-server "echo 'âœ… SSH connection successful'"
    
    - name: Prepare deployment files
      run: |
        echo "ğŸ“ Preparing deployment files..."
        
        # Create .env file for docker-compose
        cat > .env.prod << EOF
        APP_NAME=${{ env.APP_NAME }}
        DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
        DOCKER_IMAGE_NAME=${{ env.DOCKER_IMAGE_NAME }}
        APP_VERSION=${{ needs.build.outputs.version }}
        VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
        VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
        EOF
        
        # Create SSL generation script
        cat > generate-ssl.sh << 'EOF'
        #!/bin/bash
        set -e
        
        DOMAIN="$1"
        SSL_VOLUME="ssl-certs"
        
        echo "ğŸ” Generating SSL certificates for domain: $DOMAIN"
        
        # Create temporary directory
        TEMP_DIR=$(mktemp -d)
        
        # Generate certificates
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
          -keyout "$TEMP_DIR/selfsigned.key" \
          -out "$TEMP_DIR/selfsigned.crt" \
          -subj "/C=RU/ST=Moscow/L=Moscow/O=Birthday/CN=$DOMAIN"
        
        # Create Docker volume if not exists
        if ! docker volume inspect $SSL_VOLUME > /dev/null 2>&1; then
          docker volume create $SSL_VOLUME
        fi
        
        # Copy certificates to volume
        docker run --rm -v $SSL_VOLUME:/target -v "$TEMP_DIR:/source" alpine \
          sh -c "cp /source/* /target/ && chmod 644 /target/selfsigned.crt && chmod 600 /target/selfsigned.key"
        
        # Cleanup
        rm -rf "$TEMP_DIR"
        
        echo "âœ… SSL certificates generated and stored in Docker volume: $SSL_VOLUME"
        EOF
        
        chmod +x generate-ssl.sh
        
        # Copy files to server
        scp .env.prod deploy-server:/tmp/.env.prod
        scp generate-ssl.sh deploy-server:/tmp/generate-ssl.sh
        scp infra/docker/docker-compose.yml deploy-server:/tmp/docker-compose.yml
        
        # Create directory structure on server
        ssh deploy-server "
          mkdir -p ~/app/infra/nginx/sites
          mkdir -p ~/app/infra/docker
        "
        
        # Copy nginx configs
        scp infra/nginx/nginx.conf deploy-server:~/app/infra/nginx/
        scp infra/nginx/sites/app.conf deploy-server:~/app/infra/nginx/sites/
        
        echo "âœ… Deployment files prepared"
    
    - name: Login to GitHub Container Registry on server
      run: |
        echo "ğŸ” Logging in to GitHub Container Registry..."
        
        ssh deploy-server "
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} \
            -u '${{ github.actor }}' \
            --password-stdin
        "
    
    - name: Generate SSL certificates
      run: |
        echo "ğŸ” Generating SSL certificates..."
        
        ssh deploy-server "
          cd ~/app
          
          # Generate SSL certificates
          /tmp/generate-ssl.sh '${{ secrets.DOMAIN }}'
          
          # Verify certificates
          echo '=== SSL Certificate Info ==='
          docker run --rm -v ssl-certs:/ssl alpine \
            sh -c 'openssl x509 -in /ssl/selfsigned.crt -text -noout | grep -E \"Subject:|Not Before:|Not After:\"'
        "
    
    - name: Deploy with Docker Compose
      run: |
        echo "ğŸš€ Deploying with Docker Compose..."
        
        ssh deploy-server "
          cd ~/app
          
          # Copy deployment files
          cp /tmp/.env.prod .env
          cp /tmp/docker-compose.yml infra/docker/
          
          echo '=== Pulling latest image ==='
          docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE_NAME }}:latest
          
          echo '=== Stopping existing containers ==='
          docker-compose -f infra/docker/docker-compose.yml down
          
          echo '=== Starting new deployment ==='
          docker-compose -f infra/docker/docker-compose.yml up -d
          
          echo '=== Waiting for services to start ==='
          sleep 10
          
          echo '=== Deployment Status ==='
          docker-compose -f infra/docker/docker-compose.yml ps
          
          echo '=== Container Health Status ==='
          docker ps --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}' | grep ${{ env.APP_NAME }}
          
          echo '=== Health Checks ==='
          echo 'App health:'
          curl -f http://localhost:3000/health || echo 'App health check failed'
          echo ''
          echo 'Nginx health:'
          docker exec ${{ env.APP_NAME }}-nginx nginx -t && echo 'Nginx config OK'
          
          echo '=== Logs (last 5 lines) ==='
          docker logs ${{ env.APP_NAME }}-app --tail 5 2>&1
          docker logs ${{ env.APP_NAME }}-nginx --tail 5 2>&1
        "
    
    - name: Verify deployment health
      run: |
        echo "ğŸ” Verifying deployment health..."
        
        sleep 15
        
        ssh deploy-server "
          echo '=== Comprehensive Health Check ==='
          
          # Check containers are running
          echo '1. Container Status:'
          if docker ps --filter 'name=${{ env.APP_NAME }}' --format 'table {{.Names}}\\t{{.Status}}' | grep -q 'Up'; then
            echo 'âœ… All containers are running'
          else
            echo 'âŒ Some containers are not running'
            exit 1
          fi
          
          # Check app health
          echo ''
          echo '2. Application Health Endpoints:'
          APP_HEALTH=\$(curl -s -o /dev/null -w '%{http_code}' http://localhost:3000/health)
          if [ \"\$APP_HEALTH\" = \"200\" ]; then
            echo 'âœ… App health check: 200 OK'
          else
            echo \"âŒ App health check failed: \$APP_HEALTH\"
          fi
          
          # Check version endpoint
          echo ''
          echo '3. Version Information:'
          curl -s http://localhost:3000/version || echo 'Version endpoint unavailable'
          
          # Check nginx proxy
          echo ''
          echo '4. Nginx Proxy Health:'
          NGINX_HEALTH=\$(curl -s -o /dev/null -w '%{http_code}' http://localhost/health)
          if [ \"\$NGINX_HEALTH\" = \"200\" ]; then
            echo 'âœ… Nginx proxy health: 200 OK'
          else
            echo \"âŒ Nginx proxy health failed: \$NGINX_HEALTH\"
          fi
          
          # Check SSL
          echo ''
          echo '5. SSL Certificate:'
          if docker exec ${{ env.APP_NAME }}-nginx ls /etc/nginx/ssl/selfsigned.crt > /dev/null 2>&1; then
            echo 'âœ… SSL certificate found'
          else
            echo 'âš ï¸ SSL certificate not found'
          fi
          
          # Resource usage
          echo ''
          echo '6. Resource Usage:'
          docker stats ${{ env.APP_NAME }}-app ${{ env.APP_NAME }}-nginx --no-stream --format 'table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.NetIO}}'
        "
        
        echo ''
        echo "=== Deployment Summary ==="
        echo "âœ… Docker Compose deployment completed"
        echo "ğŸ“¦ Application: ${{ env.APP_NAME }}"
        echo "ğŸ·ï¸ Version: ${{ needs.build.outputs.version }}"
        echo "ğŸ”— Internal: http://localhost:3000"
        echo "ğŸŒ External: https://${{ secrets.DOMAIN }}"
        echo "ğŸ“Š Build: ${{ needs.build.outputs.build_id }}"

  # ==================== NOTIFICATION ====================
  notify:
    name: ğŸ“¨ Send Notification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    timeout-minutes: 5
    
    steps:
    - name: Checkout for git info
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get commit info
      id: commit_info
      run: |
        COMMIT_SHORT="${GITHUB_SHA:0:7}"
        COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an")
        COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" | head -n1)
        BRANCH="${GITHUB_REF#refs/heads/}"
        
        echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
        echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
        echo "commit_message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT
    
    - name: Send Telegram notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        APP_NAME: ${{ env.APP_NAME }}
        VERSION: ${{ needs.build.outputs.version }}
        BUILD_ID: ${{ needs.build.outputs.build_id }}
        COMMIT_SHORT: ${{ steps.commit_info.outputs.commit_short }}
        COMMIT_AUTHOR: ${{ steps.commit_info.outputs.commit_author }}
        COMMIT_MESSAGE: ${{ steps.commit_info.outputs.commit_message }}
        BRANCH: ${{ steps.commit_info.outputs.branch }}
        SERVER_IP: ${{ secrets.SERVER_IP }}
        DOMAIN: ${{ secrets.DOMAIN }}
        VALIDATE_RESULT: ${{ needs.validate.result }}
        SECURITY_RESULT: ${{ needs.security.result }}
        BUILD_RESULT: ${{ needs.build.result }}
        DEPLOY_RESULT: ${{ needs.deploy.result }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}
      run: |
        echo "ğŸ“¨ Sending Telegram notification..."
        
        # Determine status
        if [ "$DEPLOY_RESULT" = "success" ]; then
          STATUS_EMOJI="ğŸ‰"
          STATUS_TEXT="Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ âœ…"
          STATUS_ICON="ğŸŸ¢"
        else
          STATUS_EMOJI="âŒ"
          STATUS_TEXT="ĞĞ¨Ğ˜Ğ‘ĞšĞ ğŸ”´"
          STATUS_ICON="ğŸ”´"
        fi
        
        # Format current time
        CURRENT_TIME=$(date '+%d.%m.%Y %H:%M:%S')
        
        # Create message with proper formatting
        cat > message.txt << EOF
${STATUS_EMOJI} Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹ $APP_NAME

${STATUS_ICON} Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: <b>${STATUS_TEXT}</b>
ğŸ“¦ Ğ’ĞµÑ€ÑĞ¸Ñ: <code>${VERSION}</code>
ğŸ·ï¸ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ°: <code>${BUILD_ID}</code>

ğŸ“ <b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğµ:</b>
â””â”€ Ğ’ĞµÑ‚ĞºĞ°: <code>${BRANCH}</code>
â””â”€ ĞšĞ¾Ğ¼Ğ¼Ğ¸Ñ‚: <code>${COMMIT_SHORT}</code>
â””â”€ ĞĞ²Ñ‚Ğ¾Ñ€: ${COMMIT_AUTHOR}
â””â”€ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: ${COMMIT_MESSAGE}

ğŸŒ <b>Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:</b>
â€¢ https://${DOMAIN}
â€¢ http://${SERVER_IP}

ğŸ”§ <b>ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ:</b>
â€¢ https://${DOMAIN}/health
â€¢ https://${DOMAIN}/version

ğŸ“Š <b>Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹:</b>
â€¢ Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ: ${VALIDATE_RESULT}
â€¢ Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ: ${SECURITY_RESULT}
â€¢ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ°: ${BUILD_RESULT}
â€¢ Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹: ${DEPLOY_RESULT}

ğŸ• ${CURRENT_TIME}
EOF
        
        # Read message
        MESSAGE=$(cat message.txt)
        
        # Escape message for JSON
        ESCAPED_MESSAGE=$(echo "$MESSAGE" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')
        
        # Create JSON for inline keyboard
        BUTTONS_JSON='{
          "inline_keyboard": [
            [
              {"text": "ğŸŒ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ", "url": "https://'"${DOMAIN}"'"},
              {"text": "ğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸", "url": "'"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"'"}
            ],
            [
              {"text": "ğŸ”§ ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒĞµ", "url": "https://'"${DOMAIN}"'/health"},
              {"text": "ğŸ“¦ Ğ’ĞµÑ€ÑĞ¸Ñ ÑĞ±Ğ¾Ñ€ĞºĞ¸", "url": "https://'"${DOMAIN}"'/version"}
            ]
          ]
        }'
        
        # Send to Telegram with buttons
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -H "Content-Type: application/json" \
          -d '{
            "chat_id": "'"${TELEGRAM_CHAT_ID}"'",
            "text": "'"${ESCAPED_MESSAGE}"'",
            "parse_mode": "HTML",
            "disable_web_page_preview": true,
            "reply_markup": '"${BUTTONS_JSON}"'
          }'
        
        echo "âœ… Telegram notification sent"
        rm -f message.txt

  # ==================== CLEANUP ====================
  cleanup:
    name: ğŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [validate, security, build, deploy, notify]
    if: always()
    
    steps:
    - name: Summary
      run: |
        echo "ğŸ“‹ ===== DEPLOYMENT SUMMARY ====="
        echo ""
        echo "ğŸ¯ Application: ${{ env.APP_NAME }}"
        echo "ğŸš€ Trigger: ${{ github.event_name }}"
        echo "ğŸ‘¤ Actor: ${{ github.actor }}"
        echo "ğŸŒ¿ Branch: ${GITHUB_REF#refs/heads/}"
        echo ""
        echo "ğŸ“Š Pipeline Results:"
        echo "  ğŸ” Validate: ${{ needs.validate.result }}"
        echo "  ğŸ”’ Security: ${{ needs.security.result }}"
        echo "  ğŸ³ Build: ${{ needs.build.result }}"
        echo "  ğŸš€ Deploy: ${{ needs.deploy.result }}"
        echo "  ğŸ“¨ Notify: ${{ needs.notify.result }}"
        echo ""
        echo "ğŸ·ï¸ Version: ${{ needs.build.outputs.version }}"
        echo "ğŸ”– Build ID: ${{ needs.build.outputs.build_id }}"
        echo "ğŸŒ URL: https://${{ secrets.DOMAIN }}"
        echo ""
        if [ "${{ job.status }}" = "success" ]; then
          echo "âœ… Docker Compose deployment completed successfully!"
          echo "ğŸ³ Containers: nginx + app (separate)"
          echo "ğŸ”’ SSL: Self-signed certificate"
          echo "ğŸ¥ Health checks: Implemented"
        else
          echo "âŒ Deployment pipeline encountered issues"
          echo "ğŸ” Check the logs for details"
        fi