name: ğŸš€ Production Deployment Pipeline

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: 'birthday-invitation'
  NODE_VERSION: '20'
  DOCKER_REGISTRY: 'ghcr.io'
  DOCKER_IMAGE_NAME: '${{ github.repository }}'

jobs:
  # ==================== VALIDATION ====================
  validate:
    name: ğŸ” Validate
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: Checkout repository with SSH
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}
    
    - name: Validate files
      run: |
        echo "ğŸ“ Validating project structure..."
        
        required_files=(
          "package.json"
        )
        
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "âŒ Missing required file: $file"
            exit 1
          else
            echo "âœ… $file found"
          fi
        done
        
        echo "âœ… Project structure validated"

  # ==================== SECURITY ====================
  security:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    needs: validate
    timeout-minutes: 10
    
    steps:
    - name: Checkout code with SSH
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}
    
    - name: Dependency audit
      run: |
        echo "ğŸ›¡ï¸ Running dependency audit..."
        
        if [ -f "package.json" ]; then
          echo "Checking npm dependencies..."
          npm audit --audit-level=moderate || echo "âš ï¸ Audit found vulnerabilities (continuing deployment)"
        else
          echo "âš ï¸ package.json not found, skipping dependency audit"
        fi
    
    - name: Check for exposed secrets
      run: |
        echo "ğŸ” Checking for exposed secrets..."
        
        # ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğµ ÑĞµĞºÑ€ĞµÑ‚Ñ‹ Ğ² ĞºĞ¾Ğ´Ğµ
        forbidden_patterns=(
          "password.*="
          "token.*="
          "secret.*="
          "api[_-]key"
          "ssh[_-]key"
          "private[_-]key"
        )
        
        found_secrets=false
        
        for pattern in "${forbidden_patterns[@]}"; do
          echo "Checking pattern: $pattern"
          if grep -r -i "$pattern" --include="*.js" --include="*.jsx" --include="*.json" --include="*.env*" . 2>/dev/null | grep -v "node_modules" | grep -v ".git" | grep -v "test" | grep -v "spec"; then
            echo "âš ï¸ Potential secret found with pattern: $pattern"
            found_secrets=true
          fi
        done
        
        if [ "$found_secrets" = true ]; then
          echo "âŒ Potential secrets found in code! Please review."
          # ĞĞµ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ, Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´Ğ°ĞµĞ¼
          echo "âš ï¸ Continuing deployment, but please review the warnings above"
        else
          echo "âœ… No obvious secrets found in code"
        fi
    
    - name: Check environment files
      run: |
        echo "ğŸ“ Checking environment files..."
        
        # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ Ñ‡Ñ‚Ğ¾ .env.local Ğ½Ğµ Ğ·Ğ°ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‡ĞµĞ½
        if [ -f ".env.local" ]; then
          echo "âŒ .env.local should not be committed to repository!"
          exit 1
        fi
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ .env.example
        if [ ! -f ".env.example" ]; then
          echo "âš ï¸ .env.example is missing! Consider creating one for documentation"
        else
          echo "âœ… .env.example found"
        fi
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ .env Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞµĞºÑ€ĞµÑ‚Ğ¾Ğ²
        for env_file in .env .env.production .env.development; do
          if [ -f "$env_file" ]; then
            echo "Checking $env_file for hardcoded secrets..."
            if grep -q "REAL_SECRET\|ACTUAL_PASSWORD\|LIVE_API_KEY" "$env_file" 2>/dev/null; then
              echo "âŒ Found potentially hardcoded secret in $env_file"
              exit 1
            fi
          fi
        done
        
        echo "âœ… Environment files check passed"
    
    - name: Docker security scan
      run: |
        echo "ğŸ³ Scanning Docker configuration..."
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Dockerfile Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼
        if [ -f "infra/docker/Dockerfile.app" ]; then
          echo "Checking Dockerfile.app..."
          
          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¹ Ğ²ĞµÑ€ÑĞ¸Ğ¸
          if grep -q "FROM node:latest" infra/docker/Dockerfile.app; then
            echo "âš ï¸ Using 'node:latest' tag is not recommended for production"
          fi
          
          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ° root Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
          if grep -q "USER root" infra/docker/Dockerfile.app; then
            echo "âš ï¸ Dockerfile runs as root, consider using non-root user"
          fi
          
          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ° Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ ÑĞµĞºÑ€ĞµÑ‚Ğ¾Ğ² Ğ² Dockerfile
          if grep -q "ARG.*TOKEN\|ARG.*SECRET\|ARG.*PASSWORD" infra/docker/Dockerfile.app; then
            echo "âš ï¸ Dockerfile contains potential secret arguments"
          fi
          
          echo "âœ… Dockerfile basic checks completed"
        else
          echo "âš ï¸ Dockerfile.app not found, skipping Docker security scan"
        fi

  # ==================== BUILD ====================
  build:
    name: ğŸ³ Build Docker Image Locally
    runs-on: ubuntu-latest
    needs: [validate, security]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    outputs:
      version: ${{ steps.extract_metadata.outputs.version }}
      build_id: ${{ steps.extract_metadata.outputs.build_id }}
      commit_short: ${{ steps.extract_metadata.outputs.commit_short }}
    
    steps:
    - name: Checkout code with SSH
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}
    
    - name: Extract metadata
      id: extract_metadata
      run: |
        # Extract version
        VERSION="1.0.0"
        if [ -f "package.json" ]; then
          VERSION=$(grep '"version"' package.json | head -1 | sed 's/.*"version": "\([^"]*\).*/\1/' || echo "1.0.0")
        fi
        
        COMMIT_SHORT="${GITHUB_SHA:0:7}"
        BUILD_ID="${COMMIT_SHORT}-$(date +%Y%m%d%H%M%S)"
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
        echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
        
        echo "ğŸ“¦ Version: $VERSION"
        echo "ğŸ·ï¸ Build ID: $BUILD_ID"
        echo "ğŸ”– Commit: $COMMIT_SHORT"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker image locally (no push)
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./infra/docker/Dockerfile.app
        push: false  # ĞĞµ Ğ¿ÑƒÑˆĞ¸Ğ¼ Ğ² registry
        tags: |
          ${{ env.APP_NAME }}:latest
          ${{ env.APP_NAME }}:${{ steps.extract_metadata.outputs.version }}
        labels: |
          org.opencontainers.image.title=${{ env.APP_NAME }}
          org.opencontainers.image.version=${{ steps.extract_metadata.outputs.version }}
          org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          org.opencontainers.image.revision=${{ github.sha }}
        build-args: |
          VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
      
    - name: Save Docker image as artifact
      run: |
        echo "ğŸ’¾ Saving Docker image as artifact..."
        docker save ${{ env.APP_NAME }}:latest -o /tmp/${{ env.APP_NAME }}.tar
        gzip /tmp/${{ env.APP_NAME }}.tar
    
    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: /tmp/${{ env.APP_NAME }}.tar.gz
        retention-days: 1

  # ==================== DEPLOY ====================
  deploy:
    name: ğŸš€ Deploy to Server
    runs-on: ubuntu-latest
    needs: [validate, security, build]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 30
    environment: 
      name: production
      url: https://${{ vars.DOMAIN }}
    
    steps:
    - name: Checkout repository with SSH
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}
    
    - name: Extract version
      id: extract_version
      run: |
        echo "ğŸ“¦ Extracting version..."
        
        VERSION="1.0.0"
        if [ -f "package.json" ]; then
          VERSION=$(grep '"version"' package.json | head -1 | sed 's/.*"version": "\([^"]*\).*/\1/' || echo "1.0.0")
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "âœ… Version: $VERSION"
    
    - name: Setup SSH for server connection
      run: |
        echo "ğŸ” Setting up SSH for server connection..."
        
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        cat >> ~/.ssh/config << EOF
        Host deploy-server
          HostName ${{ secrets.SERVER_IP }}
          User ${{ secrets.DEPLOY_USER }}
          IdentityFile ~/.ssh/deploy_key
          Port 22
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
          ConnectTimeout 30
        EOF
        
        chmod 600 ~/.ssh/config
        
        ssh deploy-server "echo 'âœ… SSH connection to server successful'"
    
    - name: Prepare deployment files
      env:
        APP_VERSION: ${{ steps.extract_version.outputs.version }}
      run: |
        echo "ğŸ“ Preparing deployment files..."
        echo "Using APP_VERSION: $APP_VERSION"
        
        # Create .env file
        cat > .env.prod << EOF
        APP_NAME=${{ env.APP_NAME }}
        APP_VERSION=$APP_VERSION
        VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
        VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
        EOF
        
        # Create SSL generation script
        cat > generate-ssl.sh << 'EOF'
        #!/bin/bash
        set -e
        
        DOMAIN="$1"
        SSL_VOLUME="ssl-certs"
        
        echo "ğŸ” Generating SSL certificates for domain: $DOMAIN"
        
        TEMP_DIR=$(mktemp -d)
        
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
          -keyout "$TEMP_DIR/selfsigned.key" \
          -out "$TEMP_DIR/selfsigned.crt" \
          -subj "/C=RU/ST=Moscow/L=Moscow/O=Birthday/CN=$DOMAIN"
        
        if ! docker volume inspect $SSL_VOLUME > /dev/null 2>&1; then
          docker volume create $SSL_VOLUME
        fi
        
        docker run --rm -v $SSL_VOLUME:/target -v "$TEMP_DIR:/source" alpine \
          sh -c "cp /source/* /target/ && chmod 644 /target/selfsigned.crt && chmod 600 /target/selfsigned.key"
        
        rm -rf "$TEMP_DIR"
        
        echo "âœ… SSL certificates generated"
        EOF
        
        chmod +x generate-ssl.sh
        
        # Create docker-compose.yml Ğ´Ğ»Ñ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ÑĞ±Ğ¾Ñ€ĞºĞ¸
        cat > docker-compose.yml << EOF
        version: '3.8'

        services:
          web:
            build:
              context: .
              dockerfile: infra/docker/Dockerfile.app
            image: ${{ env.APP_NAME }}:latest
            container_name: ${{ env.APP_NAME }}
            restart: unless-stopped
            ports:
              - "80:80"
              - "443:443"
            volumes:
              - ssl-certs:/etc/nginx/ssl:ro
            environment:
              - VITE_TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
              - VITE_TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_CHAT_ID }}
              - VITE_APP_VERSION=$APP_VERSION
            healthcheck:
              test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 10s

        volumes:
          ssl-certs:
            external: true
        EOF
        
        # Create nginx config
        cat > nginx.conf << 'EOF'
        user nginx;
        worker_processes auto;
        error_log /var/log/nginx/error.log warn;
        pid /var/run/nginx.pid;

        events {
            worker_connections 1024;
        }

        http {
            include /etc/nginx/mime.types;
            default_type application/octet-stream;

            log_format main '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                            '\$status \$body_bytes_sent "\$http_referer" '
                            '"\$http_user_agent" "\$http_x_forwarded_for"';

            access_log /var/log/nginx/access.log main;

            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            keepalive_timeout 65;
            types_hash_max_size 2048;

            gzip on;
            gzip_vary on;
            gzip_min_length 1024;
            gzip_types
                text/plain
                text/css
                text/xml
                text/javascript
                application/javascript
                application/xml+rss
                application/json;

            server {
                listen 80;
                server_name _;
                return 301 https://\$host\$request_uri;
            }

            server {
                listen 443 ssl http2;
                server_name _;
                
                ssl_certificate /etc/nginx/ssl/selfsigned.crt;
                ssl_certificate_key /etc/nginx/ssl/selfsigned.key;
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
                ssl_prefer_server_ciphers off;
                
                add_header X-Frame-Options "SAMEORIGIN" always;
                add_header X-Content-Type-Options "nosniff" always;
                add_header X-XSS-Protection "1; mode=block" always;
                add_header Referrer-Policy "strict-origin-when-cross-origin" always;
                add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
                
                root /usr/share/nginx/html;
                index index.html;
                
                location / {
                    try_files \$uri \$uri/ /index.html;
                }
                
                location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|webp)\$ {
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                    access_log off;
                }
                
                location ~ /\\. {
                    deny all;
                    access_log off;
                    log_not_found off;
                }
                
                location ~* \\.(log|sql|db|bak|old|orig)\$ {
                    deny all;
                    access_log off;
                    log_not_found off;
                }
                
                location /health {
                    return 200 "healthy\\n";
                    add_header Content-Type text/plain;
                }
                
                location /version {
                    alias /usr/share/nginx/html/.version;
                    add_header Content-Type text/plain;
                }
                
                error_page 404 /index.html;
                error_page 500 502 503 504 /50x.html;
                location = /50x.html {
                    root /usr/share/nginx/html;
                }
            }
        }
        EOF
        
        # Copy files to server
        scp .env.prod deploy-server:/tmp/.env.prod
        scp generate-ssl.sh deploy-server:/tmp/generate-ssl.sh
        scp docker-compose.yml deploy-server:/tmp/docker-compose.yml
        
        # Copy source code to server
        echo "ğŸ“¦ Copying source code to server..."
        ssh deploy-server "mkdir -p ~/app/src"
        rsync -avz --exclude='node_modules' --exclude='.git' --exclude='.github' ./ deploy-server:~/app/src/
        
        # Create directory structure on server
        ssh deploy-server "
          mkdir -p ~/app/infra/nginx
          mkdir -p ~/app/infra/docker
        "
        
        # Copy nginx config
        scp nginx.conf deploy-server:~/app/infra/nginx/nginx.conf
        
        echo "âœ… Deployment files prepared"
    
    - name: Generate SSL certificates on server
      run: |
        echo "ğŸ” Generating SSL certificates..."
        
        ssh deploy-server "
          cd ~/app
          
          # Generate SSL certificates
          /tmp/generate-ssl.sh '${{ secrets.DOMAIN }}'
          
          echo 'âœ… SSL certificates generated'
        "
    
    - name: Build and deploy on server
      env:
        APP_VERSION: ${{ steps.extract_version.outputs.version }}
      run: |
        echo "ğŸš€ Building and deploying on server..."
        
        ssh deploy-server "
          cd ~/app
          
          # Copy deployment files
          cp /tmp/.env.prod .env
          cp /tmp/docker-compose.yml infra/docker/
          cp -r src/infra/docker/Dockerfile.app infra/docker/ 2>/dev/null || echo 'Dockerfile already in place'
          
          echo '=== Building Docker image on server ==='
          cd src
          
          # Install dependencies and build
          echo 'Installing dependencies...'
          npm ci || npm install
          
          echo 'Building application...'
          npm run build
          
          echo 'Building Docker image...'
          docker build -f infra/docker/Dockerfile.app -t ${{ env.APP_NAME }}:latest .
          
          echo '=== Stopping existing containers ==='
          cd ~/app
          docker-compose -f infra/docker/docker-compose.yml down || true
          
          echo '=== Starting new deployment ==='
          docker-compose -f infra/docker/docker-compose.yml up -d
          
          echo '=== Waiting for services to start ==='
          sleep 10
          
          echo '=== Deployment Status ==='
          docker-compose -f infra/docker/docker-compose.yml ps
          
          echo '=== Container Health Status ==='
          docker ps --format 'table {{.Names}}\\t{{.Status}}\\t{{.Ports}}' | grep ${{ env.APP_NAME }} || echo 'Container not found'
          
          echo '=== Health Checks ==='
          echo 'Health check:'
          curl -f http://localhost/health || echo 'Health check failed'
          echo ''
          echo 'Version:'
          curl -s http://localhost/version || echo 'Version endpoint failed'
        "
    
    - name: Verify deployment
      run: |
        echo "ğŸ” Verifying deployment..."
        
        sleep 15
        
        ssh deploy-server "
          echo '=== Comprehensive Health Check ==='
          
          # Check container is running
          echo '1. Container Status:'
          if docker ps --filter 'name=${{ env.APP_NAME }}' --format 'table {{.Names}}\\t{{.Status}}' | grep -q 'Up'; then
            echo 'âœ… Container is running'
          else
            echo 'âŒ Container is not running'
            exit 1
          fi
          
          # Check health endpoint
          echo ''
          echo '2. Health Endpoint:'
          HEALTH=\$(curl -s -o /dev/null -w '%{http_code}' http://localhost/health)
          if [ \"\$HEALTH\" = \"200\" ]; then
            echo 'âœ… Health check: 200 OK'
          else
            echo \"âŒ Health check failed: \$HEALTH\"
          fi
          
          # Check version
          echo ''
          echo '3. Version Information:'
          curl -s http://localhost/version || echo 'Version endpoint unavailable'
          
          # Check SSL
          echo ''
          echo '4. SSL Certificate:'
          if docker exec ${{ env.APP_NAME }} ls /etc/nginx/ssl/selfsigned.crt > /dev/null 2>&1; then
            echo 'âœ… SSL certificate found'
          else
            echo 'âš ï¸ SSL certificate not found'
          fi
          
          # Resource usage
          echo ''
          echo '5. Resource Usage:'
          docker stats ${{ env.APP_NAME }} --no-stream --format 'table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemUsage}}' 2>/dev/null || echo 'Stats unavailable'
        "
        
        echo ''
        echo "=== Deployment Summary ==="
        echo "âœ… Docker deployment completed"
        echo "ğŸ“¦ Application: ${{ env.APP_NAME }}"
        echo "ğŸ·ï¸ Version: ${{ steps.extract_version.outputs.version }}"
        echo "ğŸŒ External: https://${{ secrets.DOMAIN }}"
        echo "ğŸ—ï¸ Build: Local on server"

  # ==================== NOTIFICATION ====================
  notify:
    name: ğŸ“¨ Send Notification
    runs-on: ubuntu-latest
    needs: [deploy, build, validate, security]
    if: always()
    timeout-minutes: 5
    
    steps:
    - name: Checkout for git info
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get commit info
      id: commit_info
      run: |
        COMMIT_SHORT="${GITHUB_SHA:0:7}"
        COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an")
        COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" | head -n1)
        BRANCH="${GITHUB_REF#refs/heads/}"
        
        echo "commit_short=$COMMIT_SHORT" >> $GITHUB_OUTPUT
        echo "commit_author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
        echo "commit_message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT
    
    - name: Send Telegram notification
      env:
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        APP_NAME: ${{ env.APP_NAME }}
        VERSION: ${{ needs.build.outputs.version }}
        BUILD_ID: ${{ needs.build.outputs.build_id }}
        COMMIT_SHORT: ${{ steps.commit_info.outputs.commit_short }}
        COMMIT_AUTHOR: ${{ steps.commit_info.outputs.commit_author }}
        COMMIT_MESSAGE: ${{ steps.commit_info.outputs.commit_message }}
        BRANCH: ${{ steps.commit_info.outputs.branch }}
        SERVER_IP: ${{ secrets.SERVER_IP }}
        DOMAIN: ${{ secrets.DOMAIN }}
        VALIDATE_RESULT: ${{ needs.validate.result }}
        SECURITY_RESULT: ${{ needs.security.result }}
        BUILD_RESULT: ${{ needs.build.result }}
        DEPLOY_RESULT: ${{ needs.deploy.result }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}
      run: |
        echo "ğŸ“¨ Sending Telegram notification..."
        
        # Determine status
        if [ "$DEPLOY_RESULT" = "success" ]; then
          STATUS_EMOJI="ğŸ‰"
          STATUS_TEXT="Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ âœ…"
          STATUS_ICON="ğŸŸ¢"
        else
          STATUS_EMOJI="âŒ"
          STATUS_TEXT="ĞĞ¨Ğ˜Ğ‘ĞšĞ ğŸ”´"
          STATUS_ICON="ğŸ”´"
        fi
        
        # Format current time
        CURRENT_TIME=$(date '+%d.%m.%Y %H:%M:%S')
        
        # Create message using printf to avoid YAML issues
        MESSAGE=$(printf '%s Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹ %s\n\n%s Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: %s\nğŸ“¦ Ğ’ĞµÑ€ÑĞ¸Ñ: %s\nğŸ·ï¸ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ°: %s\n\nğŸ“ Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğµ:\nâ””â”€ Ğ’ĞµÑ‚ĞºĞ°: %s\nâ””â”€ ĞšĞ¾Ğ¼Ğ¼Ğ¸Ñ‚: %s\nâ””â”€ ĞĞ²Ñ‚Ğ¾Ñ€: %s\nâ””â”€ Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ: %s\n\nğŸŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ:\nhttps://%s\nhttp://%s\n\nğŸ”§ ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒÑ:\nhttps://%s/health\nhttps://%s/version\n\nğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑÑ‹:\nâ€¢ Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ: %s\nâ€¢ Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ: %s\nâ€¢ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ°: %s\nâ€¢ Ğ”ĞµĞ¿Ğ»Ğ¾Ğ¹: %s\n\nğŸ• %s\n\nğŸŒ ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ: https://%s\nğŸ“Š ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸: %s/%s/actions/runs/%s' \
          "$STATUS_EMOJI" "$APP_NAME" \
          "$STATUS_ICON" "$STATUS_TEXT" "$VERSION" "$BUILD_ID" \
          "$BRANCH" "$COMMIT_SHORT" "$COMMIT_AUTHOR" "$COMMIT_MESSAGE" \
          "$DOMAIN" "$SERVER_IP" \
          "$DOMAIN" "$DOMAIN" \
          "$VALIDATE_RESULT" "$SECURITY_RESULT" "$BUILD_RESULT" "$DEPLOY_RESULT" \
          "$CURRENT_TIME" \
          "$DOMAIN" "$GITHUB_SERVER_URL" "$GITHUB_REPOSITORY" "$GITHUB_RUN_ID")
        
        # Send to Telegram
        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          -d "chat_id=${TELEGRAM_CHAT_ID}" \
          -d "text=${MESSAGE}" \
          -d "parse_mode=HTML"
        
        echo "âœ… Telegram notification sent"

  # ==================== CLEANUP ====================
  cleanup:
    name: ğŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: [validate, security, build, deploy, notify]
    if: always()
    
    steps:
    - name: Summary
      run: |
        echo "ğŸ“‹ ===== DEPLOYMENT SUMMARY ====="
        echo ""
        echo "ğŸ¯ Application: ${{ env.APP_NAME }}"
        echo "ğŸš€ Trigger: ${{ github.event_name }}"
        echo "ğŸ‘¤ Actor: ${{ github.actor }}"
        echo "ğŸŒ¿ Branch: ${GITHUB_REF#refs/heads/}"
        echo ""
        echo "ğŸ“Š Pipeline Results:"
        echo "  ğŸ” Validate: ${{ needs.validate.result }}"
        echo "  ğŸ”’ Security: ${{ needs.security.result }}"
        echo "  ğŸ³ Build: ${{ needs.build.result }}"
        echo "  ğŸš€ Deploy: ${{ needs.deploy.result }}"
        echo "  ğŸ“¨ Notify: ${{ needs.notify.result }}"
        echo ""
        echo "ğŸ·ï¸ Version: ${{ needs.build.outputs.version }}"
        echo "ğŸ”– Build ID: ${{ needs.build.outputs.build_id }}"
        echo "ğŸŒ URL: https://${{ secrets.DOMAIN }}"
        echo ""
        if [ "${{ job.status }}" = "success" ]; then
          echo "âœ… Docker deployment completed successfully!"
          echo "ğŸ³ Container: nginx with static files"
          echo "ğŸ”’ SSL: Self-signed certificate"
          echo "ğŸ¥ Health checks: Implemented"
        else
          echo "âŒ Deployment pipeline encountered issues"
          echo "ğŸ” Check the logs for details"
        fi